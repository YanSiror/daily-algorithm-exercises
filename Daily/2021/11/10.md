## 28、所有奇数长度子数组的和(LC 1588)

给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。

子数组 定义为原数组中的一个连续子序列。

请你返回 arr 中 所有奇数长度子数组的和 。

**示例**

```
示例 1：
    输入：arr = [1,4,2,5,3]
    输出：58
    解释：所有奇数长度子数组和它们的和为：
    [1] = 1
    [4] = 4
    [2] = 2
    [5] = 5
    [3] = 3
    [1,4,2] = 7
    [4,2,5] = 11
    [2,5,3] = 10
    [1,4,2,5,3] = 15
    我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
示例 2：
    输入：arr = [1,2]
    输出：3
    解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
示例 3：
    输入：arr = [10,11,12]
    输出：66
```

**代码**

暴力法 根据题目逐步划分数组然后求和, 这里实现了取子数组的算法

```c
/*
 * 输入: 数组 数组大小 起始下标 终止下标 结果数组大小
 * 输出: 数组值 / NULL
*/
int * getSubArr(int * nums,int numsSize,int start,int end,int * returnSize){
    int i,j,tag = 0;
    //判断错误
    if(start < 0 || end > numsSize - 1){
        printf("参数错误!");
        return NULL;
    }

    int * result = malloc(sizeof(int) * (end - start + 1));
    for(i = start;i <= end;i++)
        result[tag++] = nums[i];
    *returnSize = tag;
    return result;
}

int sumOddLengthSubarrays(int* arr, int arrSize){
    //暴力法
    int divide = 1,i,j,tag = 0,sum = 0;
    while(divide <= arrSize){
        for(i = 0;i < arrSize;i++){
            if(i + divide > arrSize)
                break;
            //取值
            int size;
            int * temp = getSubArr(arr,arrSize,i,i+divide-1,&size);
            for(j = 0;j < size;j++){
                sum += temp[j];
            }
        }
        divide += 2;
    }
    return sum;
}
```



## 29、括号的最大嵌套深度(LC 1614)

如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：

字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。
字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：

depth("") = 0
depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串
例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。

给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。

 **示例**

```
示例 1：
    输入：s = "(1+(2*3)+((8)/4))+1"
    输出：3
    解释：数字 8 在嵌套的 3 层括号中。
示例 2：
    输入：s = "(1)+((2))+(((3)))"
    输出：3
示例 3：
    输入：s = "1+(2*3)/(2-1)"
    输出：1
示例 4：
    输入：s = "1"
    输出：0
```

**代码**

直接遍历所有的嵌套层数, 然后得出最大的嵌套层数即可

```c
int maxDepth(char * s){
    //按照括号的匹配 进行层次的计算
    //实质上就是用 cur 记录当前字符被 几层括号 包裹
    //然后使用 max 记录 cur 遍历过字符的最大嵌套层数
    int i,max = 0,tag = -1;      //tag 用来识别是 0 左括号 还是 1 右括号
    int cur = 0;        //记录当前遍历字符前 有几层括号嵌套
    for(i = 0;i < strlen(s);i++){
        //如果有'(' 代表多一层嵌套
        if(s[i] == '('){
            tag = 0;
            cur++;      //嵌套层数 + 1
        }
            
        //如果有')' 代表少一层嵌套 嵌套终止 ()
        if(s[i] == ')'){
            cur--;
            tag = 1;
        }

        max = fmax(cur,max);
    }
    return max;
}
```



## 30、删除某些元素后的数组均值(LC 1619)

给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。

与 标准答案 误差在 10-5 的结果都被视为正确结果。

**示例**

```
示例 1：
    输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
    输出：2.00000
    解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。
示例 2：
    输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
    输出：4.00000
示例 3：
    输入：arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
    输出：4.77778
示例 4：
    输入：arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]
    输出：5.27778
示例 5：
    输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]
    输出：5.29167
```

**代码**

快排 + 删除

```c
int cmp(const void *a,const void *b){
    return *(int*)a - *(int*)b;
}

double trimMean(int* arr, int arrSize){
    //删除最大、最小的 5% 元素
    int delRange = arrSize * 0.05;
    int i;
    //排序
    qsort(arr,arrSize,sizeof(int),cmp);
    //删除最小 设为0
    for(i = 0;i < delRange;i++)
        arr[i] = 0;
    //删除最大
    for(i = arrSize - delRange;i < arrSize;i++)
        arr[i] = 0;
    //相加
    double sum = 0;
    for(i = 0;i < arrSize;i++)
        sum += arr[i];

    sum /= (arrSize - 2 * delRange);
    return sum;
}
```

