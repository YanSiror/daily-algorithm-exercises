## 79、括号的最大嵌套深度(LC 1614)

`难度简单92`

如果字符串满足以下条件之一，则可以称之为 **有效括号字符串****（valid parentheses string**，可以简写为 **VPS**）：

- 字符串是一个空字符串 `""`，或者是一个不为 `"("` 或 `")"` 的单字符。
- 字符串可以写为 `AB`（`A` 与 `B` 字符串连接），其中 `A` 和 `B` 都是 **有效括号字符串** 。
- 字符串可以写为 `(A)`，其中 `A` 是一个 **有效括号字符串** 。

类似地，可以定义任何有效括号字符串 `S` 的 **嵌套深度** `depth(S)`：

- `depth("") = 0`
- `depth(C) = 0`，其中 `C` 是单个字符的字符串，且该字符不是 `"("` 或者 `")"`
- `depth(A + B) = max(depth(A), depth(B))`，其中 `A` 和 `B` 都是 **有效括号字符串**
- `depth("(" + A + ")") = 1 + depth(A)`，其中 `A` 是一个 **有效括号字符串**

例如：`""`、`"()()"`、`"()(()())"` 都是 **有效括号字符串**（嵌套深度分别为 0、1、2），而 `")("` 、`"(()"` 都不是 **有效括号字符串** 。

给你一个 **有效括号字符串** `s`，返回该字符串的 `s` **嵌套深度** 。

 

**示例 1：**

```
输入：s = "(1+(2*3)+((8)/4))+1"
输出：3
解释：数字 8 在嵌套的 3 层括号中。
```

**示例 2：**

```
输入：s = "(1)+((2))+(((3)))"
输出：3
```

**示例 3：**

```
输入：s = "1+(2*3)/(2-1)"
输出：1
```

**示例 4：**

```
输入：s = "1"
输出：0
```

**代码**

进行嵌套, 计算有效的括号层数。

```c
int maxDepth(char * s){
    int tag = 0,max = 0;
    while(*s){
        if(*s == '(')
            tag++;
        if(*s == ')')
            tag--;
        max = fmax(max,tag);
        s++;
    }
    return max;
}
```



## 80、买卖股票的最佳时机 II(LC 122)

`难度中等1512`

给定一个数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**代码**

贪心,  实质上就是计算每一个波谷到波峰的差值, 从一开始的波谷选取累加值直到抵达波峰

```c
int maxProfit(int* prices, int pricesSize){
    int max = 0;
    int i;
     for(i = 0;i < pricesSize - 1;i++){
         if(prices[i] < prices[i+1])
            max += prices[i+1] - prices[i];
     }
     return max;
}
```



## 81、有效的数独(LC 36)

`难度中等736`

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

 

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

 

**示例 1：**

![img](img/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

**示例 2：**

```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**代码**

暴力法, 模拟规则

```c
/*
 * 输入: 整型数组
 * 输出: 经重新赋值的数组
 * 参数: 数组 数组大小 目标值
*/
void resetArrayOfInt(int * nums,int size,int value){
    int i;
    for(i = 0;i < size;i++)
        nums[i] = value;
}

bool isValidSudoku(char** board, int boardSize, int* boardColSize){
    //暴力法, 按照规则进行判断,尝试
    //1、判断列
    int i,j,k;
    int * nums = malloc(sizeof(int) * 9);   //计算出现次数 - hash array
    for(i = 0;i < boardSize;i++){
        resetArrayOfInt(nums,9,1);
        for(j = 0;j < boardColSize[0];j++){
            if(board[i][j] != '.'){
                nums[board[i][j] - '0' - 1]--;
                //出现重复,退出
                if(nums[board[i][j] - '0' - 1] < 0)
                    return false;
            }
        }
    }

    //2、判断行
    for(i = 0;i < boardSize;i++){
        resetArrayOfInt(nums,9,1);
        for(j = 0;j < boardColSize[0];j++){
            if(board[j][i] != '.'){
                nums[board[j][i] - '0' - 1]--;
                //出现重复,退出
                if(nums[board[j][i] - '0' - 1] < 0)
                    return false;
            }
        }
    }

 //3、判断 9 宫格 - 时间复杂度比较高 - 但是数独固定,相对而言可以使用
    for(i = 0;i < boardSize;i+=3){
        for(k = 0;k < 9;k+=3){
            resetArrayOfInt(nums,9,1);
            for(j = k;j < k+3;j++){
                if(board[i][j] != '.'){
                    nums[board[i][j] - '0' - 1]--;
                    //出现重复,退出
                    if(nums[board[i][j] - '0' - 1] < 0)
                        return false;
                }
            }
            for(j = k;j < k+3;j++){
                if(board[i+1][j] != '.'){
                    nums[board[i+1][j] - '0' - 1]--;
                    //出现重复,退出
                    if(nums[board[i+1][j] - '0' - 1] < 0)
                        return false;
                }
            }
            for(j = k;j < k+3;j++){
                if(board[i+2][j] != '.'){
                    nums[board[i+2][j] - '0' - 1]--;
                    //出现重复,退出
                    if(nums[board[i+2][j] - '0' - 1] < 0)
                        return false;
                }
            }
        }
    }
   
    return true;
}
```

