<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="GB2312">
    <title>数组翻转</title>
    <link rel="stylesheet" href="../../highlights/railscasts.min.css">
</head>
<body>
<h3>整型数组翻转</h3>
<pre class='hljs'>
    <code class="c">
    /*
     * 输入: 数组 长度
     * 输出: 翻转后的数组
    */
    int * reverseInt(int * nums,int size){
        int i,j;
        for(i = 0;i < size/2;i++){
            int temp = nums[i];
            nums[i] = nums[size-i-1];
            nums[size-i-1] = temp;
        }
        return nums;
    }
    </code>
</pre>

<h3>整型数字的交换</h3>
<pre class='hljs'>
    <code class="c">
        /*
         * 输入: 待交换的两个数
         * 输出: 交换后的结果
        */
        void swap(int * a,int * b){
            int temp = *a;
            *a = *b;
            *b = temp;
        }
    </code>
</pre>

<h3>整形数组最大值</h3>
<pre class='hljs'>
    <code class="c">
/*
 * 输入: 数组 数组大小 可返回的最大值下标位置
 * 输出: 最大值
*/
int getMax(int * nums,int numsSize,int * index){
    int i = 0,max = 0;
    *index = 0;		//初始化index
    for(i = 0;i < numsSize;i++){
        if(max < nums[i]){
            max = nums[i];
            *index = i;
        }
    }
    return max;
}
    </code>
</pre>

<h3>整形数组取子数组元素</h3>
<pre class='hljs'>
    <code class="c">
/*
 * 输入: 数组 数组大小 起始下标 终止下标 结果数组大小
 * 输出: 数组值 / NULL
*/
int * getSubArr(int * nums,int numsSize,int start,int end,int * returnSize){
    int i,j,tag = 0;
    //判断错误
    if(start < 0 || end > numsSize - 1){
        printf("参数错误!");
        return NULL;
    }

    int * result = malloc(sizeof(int) * (end - start + 1));
    for(i = start;i <= end;i++)
        result[tag++] = nums[i];
    *returnSize = tag;
    return result;
}
    </code>
</pre>

<h3>整型数字拆分(倒序)</h3>
<p>与输入的数字高低位 相反  `reverse order`</p>
<pre class='hljs'>
    <code class="c">
/*
 * 输入: 数字 可返回的数字位数
 * 输出: 数字拆分后的一维数组(倒序)  reverse order
*/
int * splitDigitRE(int num,int * size){
    //记录数字位数
    int length = 0,temp = num;
    while(temp){
        temp /= 10;
        length++;
    }
    *size = length;

    //划分数组
    int * nums = malloc(sizeof(int) * length);
    temp = num;
    int i = 0;
    while(temp){
        nums[i++] = temp % 10;
        temp /= 10;
    }
    return nums;
}
    </code>
</pre>

<h3>整形数组最小值</h3>
<p>与输入的数字高低位 相同  `positive order`</p>
<pre class='hljs'>
    <code class="c">
/*
 * 输入: 数字 可返回的数字位数
 * 输出: 数字拆分后的一维数组(正序 - 翻转即可) positive order
*/
int * splitDigitPO(int num,int * size){
    //记录数字位数
    int length = 0,temp = num;
    while(temp){
        temp /= 10;
        length++;
    }
    *size = length;

    //划分数组
    int * nums = malloc(sizeof(int) * length);
    temp = num;
    int i = 0;
    while(temp){
        nums[i++] = temp % 10;
        temp /= 10;
    }

    //翻转
    for(i = 0;i < length/2;i++){
        int temp = nums[i];
        nums[i] = nums[length-i-1];
        nums[length-i-1] = temp;
    }
    return nums;
}
    </code>
</pre>

<h3>整型数组合并(倒序)</h3>
<p>与输入的数字高低位 相反   `reverse order`</p>
<pre class='hljs'>
    <code class="c">
/*
 * 输入: 拆分后的数组 长度
 * 输出: 合并后的数字 reverse order
*/
int digitCombinationRO(int * nums,int size){
    int i;
    double result = 0;
    for(i = 0;i < size;i++)
        result += nums[i] * pow(10,i);
    return result;
}
    </code>
</pre>

<h3>整型数组合并(正序)</h3>
<p>与输入的数字高低位 相同   `positive order`</p>
<pre class='hljs'>
    <code class="c">
/*
 * 输入: 拆分后的数组 长度
 * 输出: 合并后的数字 positive order
*/
int digitCombinationPO(int * nums,int size){
    int i,result = 0;
    for(i = size - 1;i >= 0;i--)
        result += nums[i] * pow(10,size - i - 1);
    return result;
}
    </code>
</pre>

</body>
</html>