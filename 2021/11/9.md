## 25、K进制表示下的各位数字总和(LC 1837)

给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。

转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。

**示例**

```
示例 1：
    输入：n = 34, k = 6
    输出：9
    解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。
示例 2：
    输入：n = 10, k = 10
    输出：1
    解释：n 本身就是 10 进制。 1 + 0 = 1 。
```

**代码**

```c
int sumBase(int n, int k){
    int sum = 0;
    while(n){
        sum += n % k;
        n /= k;
    }
    return sum;
}
```



## 26、将所有数字用字符替换(LC 1844)

给你一个下标从 0 开始的字符串 s ，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。

定义一个函数 shift(c, x) ，其中 c 是一个字符且 x 是一个数字，函数返回字母表中 c 后面第 x 个字符。

比方说，shift('a', 5) = 'f' 和 shift('x', 0) = 'x' 。
对于每个 奇数 下标 i ，你需要将数字 s[i] 用 shift(s[i-1], s[i]) 替换。

请你替换所有数字以后，将字符串 s 返回。题目 保证 shift(s[i-1], s[i]) 不会超过 'z' 。

**示例**

```
示例 1：
    输入：s = "a1c1e1"
    输出："abcdef"
    解释：数字被替换结果如下：

    - s[1] -> shift('a',1) = 'b'
    - s[3] -> shift('c',1) = 'd'
    - s[5] -> shift('e',1) = 'f'
示例 2：
    输入：s = "a1b2c3d4e"
    输出："abbdcfdhe"
    解释：数字被替换结果如下：

    - s[1] -> shift('a',1) = 'b'
    - s[3] -> shift('b',2) = 'd'
    - s[5] -> shift('c',3) = 'f'
    - s[7] -> shift('d',4) = 'h'
```

**代码**

```c
char shift(char a,int count){
    return a + count;
}

char * replaceDigits(char * s){
    int i;
    for(i = 0;i < strlen(s);i++){
        if(s[i] >= '0' && s[i] <= '9')
            s[i] = shift(s[i-1],s[i] - '0');
    }
    return s;
}
```



## 27、矩阵对角线元素的和(LC 1572)

给你一个正方形矩阵 `mat`，请你返回矩阵对角线元素的和。

请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。

**示例**

![img](img/sample_1911.png)

```
示例  1：
    输入：mat = [[1,2,3],
                [4,5,6],
                [7,8,9]]
    输出：25
    解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25
    请注意，元素 mat[1][1] = 5 只会被计算一次。
示例  2：
    输入：mat = [[1,1,1,1],
                [1,1,1,1],
                [1,1,1,1],
                [1,1,1,1]]
    输出：8
示例 3：
    输入：mat = [[5]]
    输出：5
```

**代码**

简单迭代

```c
int diagonalSum(int** mat, int matSize, int* matColSize){
    //计算主副对角线元素之和 去除重复元素
    //计算元素和
    int i,j,sum = 0;
    for(i = 0;i < matSize;i++){
        for(j = 0;j < matColSize[0];j++){
            //主对角线元素
            if(i == j)  sum += mat[i][j];  
            //副对角线元素
            else if(matSize - i - 1 == j)   sum += mat[i][j];  
        }
    }
    return sum;
}
```

