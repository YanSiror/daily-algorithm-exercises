## 88、十进制整数的反码

每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。

二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 "101" 的二进制反码为 "010"。

给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。

 **示例**

```
示例 1：
    输入：5
    输出：2
    解释：5 的二进制表示为 "101"，其二进制反码为 "010"，也就是十进制中的 2 。
示例 2：
    输入：7
    输出：0
    解释：7 的二进制表示为 "111"，其二进制反码为 "000"，也就是十进制中的 0 。
示例 3：
    输入：10
    输出：5
    解释：10 的二进制表示为 "1010"，其二进制反码为 "0101"，也就是十进制中的 5 。
```

**代码**

```c
/*
 * 输入: 整数 num 可返回的长度 size
 * 输出: 转换后的二进制的数组  数组长度参数
 * 说明: 该数组返回的数组结果从小端的 从个位开始, 并且正负值转换后都得到的是正值
 * 		如: -1/1 -> 1    -2/2 -> 10   -3/3 -> 11 
*/
int * tenToBinArray(int num,int * size){
    //边界条件 - 0
    if(!num){
        *size = 1;
        int * nums= malloc(sizeof(int) * *size);
        nums[0] = 0;
        return nums;
    }

    //计算长度 - 无关正负, 取绝对值
    int temp = abs(num);
    int len = 0;
    while(temp){
        temp /= 2;
        len++;
    }

    //转换为2进制, 保存到数组
    int * nums= malloc(sizeof(int) * len);
    int tag = 0,i;  //tag用于移动nums数组下标

    temp = abs(num);
    while(temp){
        nums[tag++] = temp % 2;
        temp /= 2;
    }
    *size = len;
    return nums;
}

int bitwiseComplement(int n){
    //十进制转2进制数组
    int size;
    int * binnums = tenToBinArray(n,&size);
    //按位取反 + 二进制转十进制数字
    int i,result=0;
    for(i = 0;i < size;i++){
        binnums[i] = binnums[i] == 1 ? 0 : 1;
        result +=  binnums[i] * pow(2,i);
    }
    return result;
}
```



## 89、删除最外层的括号

有效括号字符串为空 ""、"(" + A + ")" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。

例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。
如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。

 **示例**

```c
示例 1：
    输入：s = "(()())(())"
    输出："()()()"
    解释：
    输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
    删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
示例 2：
    输入：s = "(()())(())(()(()))"
    输出："()()()()(())"
    解释：
    输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
    删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
示例 3：
    输入：s = "()()"
    输出：""
    解释：
    输入字符串为 "()()"，原语化分解得到 "()" + "()"，
    删除每个部分中的最外层括号后得到 "" + "" = ""。
```

**代码**

忽略最外层的括号, 每次从 `count = 1` 开始计数进行赋值

```c
char * removeOuterParentheses(char * s){
    //赋值法 忽略最外层的括号, 取内层括号进行赋值
    int i, count = 0, tag = 0,size = strlen(s);
    for(i = 0; i < size; i++){
        if(s[i] == '('){
            count++;
            if(count>1)
                s[tag++] = '(';
        }
        else{
            count--;
            if(count>0)
                s[tag++] = ')';
        }
    }
    s[tag] = '\0';      // 这行也记得要！
    return s;
}
```



## 90、除数博弈

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一  `x`，满足 `0 < x < N 且 N % x == 0 。`
用 `N - x` 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 `True`，否则返回 `False`。假设两个玩家都以最佳状态参与游戏。

 **示例**

```
示例 1：

输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
示例 2：

输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
```

**代码**

实质上就是博弈心理, 由于爱丽丝先手, 那么在 n 为偶数情况下, 爱丽丝选 1 即可胜利。 但是偶数时, 无论爱丽丝选几, 最终鲍勃都会选恰当得数而不拜。 也即谁拿到偶数 N 谁就胜利。

```c
bool divisorGame(int n){
    return n % 2 == 0 ? true : false;
}
```

