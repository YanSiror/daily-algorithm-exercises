1748、唯一元素的和（LC ）
给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。

请你返回 nums 中唯一元素的 和 。


示例 1：

输入：nums = [1,2,3,2]
输出：4
解释：唯一元素为 [1,3] ，和为 4 。
示例 2：

输入：nums = [1,1,1,1,1]
输出：0
解释：没有唯一元素，和为 0 。
示例 3 ：

输入：nums = [1,2,3,4,5]
输出：15
解释：唯一元素为 [1,2,3,4,5] ，和为 15 。

代码
快排 + 去重
int cmp(const void *a,const void *b){
    return *(int*)a - *(int*)b;
}

int sumOfUnique(int* nums, int numsSize){
    //边界条件
    if(numsSize == 1)
        return nums[0];
    qsort(nums,numsSize,sizeof(int),cmp);   //快速排序
    //得到不重复的数字
    int i = 0,sum = 0,value = 0;    //value 标识当前比较值
    for(i = 0;i < numsSize - 1;i++){
        if(nums[i] == nums[i+1]){
            value = nums[i];
            continue;
        }
        //标识完成 
        if(nums[i] == value)
            continue;
        sum += nums[i];
    }
    //判断最后一位
    if(nums[numsSize - 2] != nums[numsSize - 1])
        sum += nums[numsSize - 1];
    return sum;
}

1827、最少操作使数组递增
给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。

比方说，如果 nums = [1,2,3] ，你可以选择增加 nums[1] 得到 nums = [1,3,3] 。
请你返回使 nums 严格递增 的 最少 操作次数。

我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 <= i < nums.length - 1 都有 nums[i] < nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。


示例 1：

输入：nums = [1,1,1]
输出：3
解释：你可以进行如下操作：
1) 增加 nums[2] ，数组变为 [1,1,2] 。
2) 增加 nums[1] ，数组变为 [1,2,2] 。
3) 增加 nums[2] ，数组变为 [1,2,3] 。
示例 2：

输入：nums = [1,5,2,4,1]
输出：14
示例 3：

输入：nums = [8]
输出：0

代码

int minOperations(int* nums, int numsSize){
    //严格递增的含义就是元素必须是递增的，不能存在相等
    //1、查找到第一个冲突的位置，也即不递增
    //边界条件
    if(numsSize == 1)
        return 0;
    int i,index = 0,value = 0;
    for(i = 0;i < numsSize - 1;i++){
        //从下一个位置开始
        if(nums[i] >= nums[i+1]){
            index = i + 1;
            value = nums[i] + 1;
            break;
        }
    }
    //开始操作
    int times = 0;  //相加次数
    for(i = index;i < numsSize;i++){
        if(value > nums[i]){
            times += value - nums[i];
            value++;
        } else if(value < nums[i]){
            value = nums[i] + 1;
        } else  
            value++;
    }
    return times;
}

1832、判断句子是否是全字母句
全字母句 指包含英语字母表中每个字母至少一次的句子。

给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。

如果是，返回 true ；否则，返回 false 。


示例 1：

输入：sentence = "thequickbrownfoxjumpsoverthelazydog"
输出：true
解释：sentence 包含英语字母表中每个字母至少一次。
示例 2：

输入：sentence = "leetcode"
输出：false

代码
bool checkIfPangram(char * sentence){
    //间接数组 + 哈希思想
    int nums[26] = {0};
    int i;
    for(i = 0;i < strlen(sentence);i++)
        nums[sentence[i] - 'a'] = 1;
    
    for(i = 0;i < 26;i++)
        if(nums[i] == 0)
            break;
    return i == 26;
}

1837、K进制表示下的各位数字总和
给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。

转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。

 

示例 1：

输入：n = 34, k = 6
输出：9
解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。
示例 2：

输入：n = 10, k = 10
输出：1
解释：n 本身就是 10 进制。 1 + 0 = 1 。

代码
int sumBase(int n, int k){
    int sum = 0;
    while(n){
        sum += n % k;
        n /= k;
    }
    return sum;
}

1844、将所有数字用字符替换
给你一个下标从 0 开始的字符串 s ，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。

定义一个函数 shift(c, x) ，其中 c 是一个字符且 x 是一个数字，函数返回字母表中 c 后面第 x 个字符。

比方说，shift('a', 5) = 'f' 和 shift('x', 0) = 'x' 。
对于每个 奇数 下标 i ，你需要将数字 s[i] 用 shift(s[i-1], s[i]) 替换。

请你替换所有数字以后，将字符串 s 返回。题目 保证 shift(s[i-1], s[i]) 不会超过 'z' 。

 

示例 1：

输入：s = "a1c1e1"
输出："abcdef"
解释：数字被替换结果如下：
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('c',1) = 'd'
- s[5] -> shift('e',1) = 'f'
示例 2：

输入：s = "a1b2c3d4e"
输出："abbdcfdhe"
解释：数字被替换结果如下：
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('b',2) = 'd'
- s[5] -> shift('c',3) = 'f'
- s[7] -> shift('d',4) = 'h'

代码

char shift(char a,int count){
    return a + count;
}

char * replaceDigits(char * s){
    int i;
    for(i = 0;i < strlen(s);i++){
        if(s[i] >= '0' && s[i] <= '9')
            s[i] = shift(s[i-1],s[i] - '0');
    }
    return s;
}