> 2021.10.17   		 1 - 3
>
> 2021.10.18   		 4 - 6
>
> 2021.10.19   		 7 - 9
>
> 2021.10.20   		 10 - 12
>
> 2021.10.21			13 - 15
>
> 2021.10.22			 16 - 18
>
> 2021.10.23 			19 - 21
>
> 2021.10.24			 22 - 24
>
> 2021.10.25			 25 - 27
>
> 2021.10.26			 28 - 30
>
> 2021.10.27 			31 - 33
>
> 2021.10.28			 33 - 36
>
> 2021.10.29			 37 - 39
>
> 2021.10.30			 40 - 42
>
> 2021.10.31 			43 - 45



## 1、删除重复的电子邮箱

编写一个 SQL 查询，来删除 `Person` 表中所有重复的电子邮箱，重复的邮箱里只保留 **Id** *最小* 的那个。

```sql
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id 是这个表的主键。
```

例如，在运行你的查询语句之后，上面的 `Person` 表应返回以下几行:

```sql
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
```

**代码**

```sql
DELETE b
FROM 
    Person AS a,
    Person AS b
WHERE 
    a.Email = b.Email AND a.Id < b.Id;
```



## 2、上升的温度

表 `Weather`

```sql
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
id 是这个表的主键
该表包含特定日期的温度信息
```

编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 `id` 。

返回结果 **不要求顺序** 。

查询结果格式如下例：

```sql
Weather
+----+------------+-------------+
| id | recordDate | Temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+

Result table:
+----+
| id |
+----+
| 2  |
| 4  |
+----+
2015-01-02 的温度比前一天高（10 -> 25）
2015-01-04 的温度比前一天高（20 -> 30）
```

**代码**

```sql
SELECT a.id
FROM 
    Weather a, 
    Weather b
WHERE
    a.Temperature > b.Temperature AND dateDiff(a.recordDate,b.recordDate) = 1;
```



## 3、大的国家

这里有张 `World` 表

```sql
+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
```

如果一个国家的面积超过 300 万平方公里，或者人口超过 2500 万，那么这个国家就是大国家。

编写一个 SQL 查询，输出表中所有大国家的名称、人口和面积。

例如，根据上表，我们应该输出:

```sql
+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
```

**代码**

```sql
SELECT name,population,area
FROM World
WHERE population > 25000000 OR area > 3000000;
```



## 4、超过5名学生的课

有一个`courses` 表 ，有: **student (学生)** 和 **class (课程)**。

请列出所有超过或等于5名学生的课。

例如，表：

```sql
+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+
```

应该输出:

```sql
+---------+
| class   |
+---------+
| Math    |
+---------+
```

**代码**

```sql
SELECT class
FROM courses
GROUP BY class
HAVING COUNT(DISTINCT student) >= 5;
```



## 5、有趣的电影

某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。

作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。

例如，下表 `cinema`:

```sql
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
```

对于上面的例子，则正确的输出是为：

```sql
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
```

**代码**

```sql
SELECT *
FROM cinema
WHERE description != 'boring' AND id % 2 != 0 
ORDER BY rating DESC;
```



## 6、变更性别

`Salary` 表：

```sql
+-------------+----------+
| Column Name | Type     |
+-------------+----------+
| id          | int      |
| name        | varchar  |
| sex         | ENUM     |
| salary      | int      |
+-------------+----------+
id 是这个表的主键。
sex 这一列的值是 ENUM 类型，只能从 ('m', 'f') 中取。
本表包含公司雇员的信息。
```

请你编写一个 SQL 查询来交换所有的 'f' 和 'm' （即，将所有 'f' 变为 'm' ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。

注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。

查询结果如下例所示：

```sql
Salary 表：
+----+------+-----+--------+
| id | name | sex | salary |
+----+------+-----+--------+
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
+----+------+-----+--------+

Result 表：
+----+------+-----+--------+
| id | name | sex | salary |
+----+------+-----+--------+
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
+----+------+-----+--------+
(1, A) 和 (3, C) 从 'm' 变为 'f' 。
(2, B) 和 (4, D) 从 'f' 变为 'm' 。
```

**代码**

```sql
UPDATE Salary 
SET sex = IF(sex = "f","m","f")
```



## 7、重新格式化部门表

部门表 `Department`：

```sql
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| revenue       | int     |
| month         | varchar |
+---------------+---------+
(id, month) 是表的联合主键。
这个表格有关于每个部门每月收入的信息。
月份（month）可以取下列值 ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]。
```

编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 **每个月** 的收入（revenue）列。

查询结果格式如下面的示例所示：

```sql
Department 表：
+------+---------+-------+
| id   | revenue | month |
+------+---------+-------+
| 1    | 8000    | Jan   |
| 2    | 9000    | Jan   |
| 3    | 10000   | Feb   |
| 1    | 7000    | Feb   |
| 1    | 6000    | Mar   |
+------+---------+-------+

查询得到的结果表：
+------+-------------+-------------+-------------+-----+-------------+
| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |
+------+-------------+-------------+-------------+-----+-------------+
| 1    | 8000        | 7000        | 6000        | ... | null        |
| 2    | 9000        | null        | null        | ... | null        |
| 3    | null        | 10000       | null        | ... | null        |
+------+-------------+-------------+-------------+-----+-------------+

注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。
```

**代码**

```sql
# Write your MySQL query statement below
SELECT DISTINCT id,
    sum(IF(month="Jan",revenue,null)) as Jan_Revenue,
    sum(IF(month="Feb",revenue,null)) as Feb_Revenue,
    sum(IF(month="Mar",revenue,null)) as Mar_Revenue,
    sum(IF(month="Apr",revenue,null)) as Apr_Revenue,
    sum(IF(month="May",revenue,null)) as May_Revenue,
    sum(IF(month="Jun",revenue,null)) as Jun_Revenue,
    sum(IF(month="Jul",revenue,null)) as Jul_Revenue,
    sum(IF(month="Aug",revenue,null)) as Aug_Revenue,
    sum(IF(month="Sep",revenue,null)) as Sep_Revenue,
    sum(IF(month="Oct",revenue,null)) as Oct_Revenue,
    sum(IF(month="Nov",revenue,null)) as Nov_Revenue,
    sum(IF(month="Dec",revenue,null)) as Dec_Revenue
    FROM Department GROUP BY id ORDER BY id;
```



## 8、快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。

**示例**

```
示例 1：
    输入：19
    输出：true
    解释：
    12 + 92 = 82
    82 + 22 = 68
    62 + 82 = 100
    12 + 02 + 02 = 1
示例 2：
    输入：n = 2
    输出：false
```

**代码**

```C
//求每位数的平方和
int getsum(int n)
{
    int sum=0;
    while(n)
    {
        sum += (n%10)*(n%10);
        n/=10;
    }
    return sum;
}

//这里比较模糊的概念是终止条件
//现在可以得到当判断快乐数的循环重复进行时, 也即 12 - 5 - 25 - 27 - 53 - 34 - 25
//在这里发生了重复, 所以它不是一个快乐数 , 也即快慢指针相撞了。
bool isHappy(int n){
    int slow=n,quick=n;
    do
    {
        //快指针每次走两步
        quick = getsum(quick);
        quick = getsum(quick); 
        //慢指针每次走一步         
        slow = getsum(slow); 
        //成功条件           
        if(slow==1 || quick==1)
            return true;
    }while(quick != slow);      //失败条件
    return false;
}
```



## 9、重复 N 次的元素(LC 961)

在大小为 `2N` 的数组 `A` 中有 `N+1` 个不同的元素，其中有一个元素重复了 `N` 次。

返回重复了 `N` 次的那个元素。

**示例**

```
示例 1：

输入：[1,2,3,3]
输出：3
示例 2：

输入：[2,1,2,5,3,2]
输出：2
示例 3：

输入：[5,1,5,2,5,3,5,4]
输出：5
```

**代码**

```c
int repeatedNTimes(int* nums, int numsSize){
    //暴力法遍历
    int i,j;
    for(i = 0;i < numsSize;i++){
        int times = 0;
        for(j = 0;j < numsSize;j++){
            if(nums[i] == nums[j])
                times++;
        }
        if(times == numsSize/2)
            break;
    }
    return nums[i];
}
```



## 10、链表中的下一个更大结点(LC 1019)

给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。

每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。

返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。

注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。

**示例**

```
示例 1：

输入：[2,1,5]
输出：[5,5,0]
示例 2：

输入：[2,7,4,3,5]
输出：[7,0,5,5,0]
示例 3：

输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]
```

**代码**

```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* nextLargerNodes(struct ListNode* head, int* returnSize){
    // 根据题解的意思是,返回结点i后第一个比其值大的结点,如果没有就返回0
    struct ListNode * p,*q,*k;
    p = head;
    //获取链表长度
    int len = 0;
    while(p){
        len++;
        p = p->next;
    }
    int * result = (int*)malloc(sizeof(int)*len);       //动态生成数组空间
    p = head;
    q = head->next;
    
    // p指向当前结点,q指向q的下一个结点
    //循环当p的值小于第一个q向后遍历获取的结点值时 break 并将该值赋值给result数组
    int i = 0;
    while(p){
        //分配空间 - 结果结点
        struct ListNode * h = (struct ListNode *)malloc(sizeof(struct ListNode));
        h->val = 0;         //初始为0, 如果没有大的值就为0
        while(q){
            //找到结果结点
            if(p->val < q->val){
                h->val = q->val;
                break;
            }
            q = q->next;
        }
        //向结果集合赋值
        result[i++] = h->val;
        p = p->next;                //后移节点
        if(p)
            q = p->next;            //后移节点
    }
    *returnSize = len;      //返回的数组大小
    return result;
}
```



## 11、特殊数组的特征值

给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。

注意： x 不必 是 nums 的中的元素。

如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。

**示例**

```
示例 1：

输入：nums = [3,5]
输出：2
解释：有 2 个元素（3 和 5）大于或等于 2 。
示例 2：

输入：nums = [0,0]
输出：-1
解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。
如果 x = 0，应该有 0 个元素 >= x，但实际有 2 个。
如果 x = 1，应该有 1 个元素 >= x，但实际有 0 个。
如果 x = 2，应该有 2 个元素 >= x，但实际有 0 个。
x 不能取更大的值，因为 nums 中只有两个元素。
示例 3：

输入：nums = [0,4,3,0,4]
输出：3
解释：有 3 个元素大于或等于 3 。
示例 4：

输入：nums = [3,6,7,7,0]
输出：-1
```

**代码**

```c
int specialArray(int* nums, int numsSize){
    //算法的终止条件是数组长度
    //从1开始 0 是不可能的, 因为不可能恰有0个数据大于等于0
    int i,j,tag=0;
    for(i = 1;i <= numsSize;i++){
        int times = 0;
        for(j = 0;j < numsSize;j++){
            if(i <= nums[j])
                times++;
        }
        if(times == i){
            tag = 1;
            break;
        }
   }
   return tag == 0 ? -1 : i;
}
```



## 12、链表中倒数第k个结点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

**示例**

```
示例：
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
```

**代码**

```c
struct ListNode * getKthFromEnd(struct ListNode* head, int k){
    //取链表大小
    struct ListNode* p,q;
    p = head;
    int len = 0;
    while(p){
        len++;
        p = p->next;
    }
    p = head;

    // 取倒数第k个就相当于取正数 len - k + 1 结点(后移次数len - k)
    int tag = len - k;
    while(tag--){
        p = p->next;
    }
    return p;
}
```



## 13、种花问题(LC 605)

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。

**示例**

```
示例 1：

输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
示例 2：

输入：flowerbed = [1,0,0,0,1], n = 2
输出：false
```

**代码**

主要在于边界条件的确定,不能够下标越界

```c
bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){
    //该题实际上是找 能种下花的位置个数
    //有以下的情况
    // 空 0 0    0 0 0    0 0 空 中间的 0 种植
    //也即找 左右都没有种植花(1) 的 0 个数
    int i;
    int position = 0;
    //边界
    if(flowerbedSize == 1 && flowerbed[0] == 0){
        position=1;
        flowerbedSize=0;        //不再执行循环
    }
        
    for(i = 0;i < flowerbedSize;i++){
        tag = 0;
        //左边界判断
        if(flowerbed[i] == 0 && i == 0 && flowerbed[i+1] == 0){
            position++;
            flowerbed[i]=1;     //种植上,方便后续计算
        }
        //右边界判断 - 防止越界
        else if(flowerbed[i] == 0 && i == flowerbedSize-1 && flowerbed[i-1] == 0){
            position++;
            flowerbed[i]=1;     //种植上,方便后续计算
        }
        //刨除左右边界计算的情况
        if(i != 0 && i != flowerbedSize-1){
            if(flowerbed[i] == 0 && flowerbed[i-1] == 0 && flowerbed[i+1] == 0){
                position++;
                flowerbed[i]=1;     //种植上,方便后续计算
            }
        }

    }
    return position >= n ? true : false;
}
```



## 14、第二高的薪资

编写一个 SQL 查询，获取 `Employee` 表中第二高的薪水（Salary） 。

```sql
+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
```

例如上述 `Employee` 表，SQL查询应该返回 `200` 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 `null`。

```sql
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
```

**代码**

外层 SELECT 是为了输出null, 内层 SELECT 使用 LIMIT 输出了降序排序后位于第二位的数据。  LIMIT 偏移为第 1 行(0开始), 数据个数 1 个(offset , count)。

```sql
SELECT
    (SELECT DISTINCT
            Salary
        FROM
            Employee
        ORDER BY Salary DESC
        LIMIT 1 OFFSET 1) AS SecondHighestSalary;
```

**LIMIT 概述**

在`SELECT`语句中使用`LIMIT`子句来约束结果集中的行数。`LIMIT`子句接受一个或两个参数。两个参数的值必须为零或正整数

下面说明了两个参数的`LIMIT`子句语法：

```sql
SELECT 
    column1,column2,...
FROM
    table
LIMIT offset , count;
SQL
```

我们来查看`LIMIT`子句参数：

- `offset`参数指定要返回的第一行的偏移量。第一行的偏移量为`0`，而不是`1`。
- `count`指定要返回的最大行数。



## 15、两个数组之间的距离(LC 1385)

给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。

「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d 。

**示例**

```
示例 1：

输入：arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
输出：2
解释：
对于 arr1[0]=4 我们有：
|4-10|=6 > d=2 
|4-9|=5 > d=2 
|4-1|=3 > d=2 
|4-8|=4 > d=2 
所以 arr1[0]=4 符合距离要求

对于 arr1[1]=5 我们有：
|5-10|=5 > d=2 
|5-9|=4 > d=2 
|5-1|=4 > d=2 
|5-8|=3 > d=2
所以 arr1[1]=5 也符合距离要求

对于 arr1[2]=8 我们有：
|8-10|=2 <= d=2
|8-9|=1 <= d=2
|8-1|=7 > d=2
|8-8|=0 <= d=2
	存在距离小于等于 2 的情况，不符合距离要求 
	故而只有 arr1[0]=4 和 arr1[1]=5 两个符合距离要求，距离值为 2
示例 2：
	输入：arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
	输出：2
示例 3：
	输入：arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
	输出：1

```

**代码**

```c
int findTheDistanceValue(int* arr1, int arr1Size, int* arr2, int arr2Size, int d){
    //暴力 双层循环
    int i,j;
    int distance = 0;
    for(i = 0;i < arr1Size;i++){
        for(j = 0;j < arr2Size;j++){
            if(abs(arr1[i] - arr2[j]) <= d)
                break;
        }
        if(j == arr2Size)
            distance++;
    }
    return distance;
}
```



## 16、移除链表元素(LC 203)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例**

```
示例 1：
	输入：head = [1,2,6,3,4,5,6], val = 6
	输出：[1,2,3,4,5]
示例 2：
	输入：head = [], val = 1
	输出：[]
示例 3：
	输入：head = [7,7,7,7], val = 7
	输出：[]
```

**代码**

```c
struct ListNode* removeElements(struct ListNode* head, int val){
    struct ListNode * p,*q;
    p = (struct ListNode *)malloc(sizeof(struct ListNode));
    p->next = head;
    q = p;

    while(q->next){
        if(q->next->val == val){
            q->next = q->next->next;
        } else{
            q = q->next;
        }
    }
    return p->next;
}   
```



## 17、同构字符串(LC205)

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

**示例**

```c
示例 1:
	输入：s = "egg", t = "add"
	输出：true
示例 2：
	输入：s = "foo", t = "bar"
	输出：false
示例 3：
	输入：s = "paper", t = "title"
	输出：true
```

**代码**

```c
struct HashTable {
    char key;
    char val;
    UT_hash_handle hh;
};

bool isIsomorphic(char* s, char* t) {
    struct HashTable* s2t = NULL;
    struct HashTable* t2s = NULL;
    int len = strlen(s);
    for (int i = 0; i < len; ++i) {
        char x = s[i], y = t[i];
        struct HashTable *tmp1, *tmp2;
        HASH_FIND(hh, s2t, &x, sizeof(char), tmp1);
        HASH_FIND(hh, t2s, &y, sizeof(char), tmp2);
        if (tmp1 != NULL) {
            if (tmp1->val != y) {
                return false;
            }
        } else {
            tmp1 = malloc(sizeof(struct HashTable));
            tmp1->key = x;
            tmp1->val = y;
            HASH_ADD(hh, s2t, key, sizeof(char), tmp1);
        }
        if (tmp2 != NULL) {
            if (tmp2->val != x) {
                return false;
            }
        } else {
            tmp2 = malloc(sizeof(struct HashTable));
            tmp2->key = y;
            tmp2->val = x;
            HASH_ADD(hh, t2s, key, sizeof(char), tmp2);
        }
    }
    return true;
}
```

算法正确, 超出时间限制

```c
bool isIsomorphic(char * s, char * t){
    int length = strlen(s);     //获取长度
    //使用间接数组存放对比结果 ASCII 码
    int ** form = malloc(sizeof(int *)*2);
    form[0] = malloc(sizeof(int)*length);
    form[1] = malloc(sizeof(int)*length);

    //存放映射关系
    int i = 0;
    while(i < length){
        form[0][i] = (int)*(s+i);
        form[1][i] = (int)*(t+i);
        i++;
    }

    int size = i;
    int j;
    //存放了i个映射关系,比较是否存在不对应的映射,也即1 对 5 和 1 对 7 同时存在
    for(i = 0;i < size;i++){
        for(j = 0;j < size;j++){
            if(form[0][i] == form[0][j] && form[1][i] != form[1][j])
                return false;
            if(form[0][i] != form[0][j] && form[1][i] == form[1][j])
                return false;
            //删除已经比较过的数据,降低复杂度
        }
    }
    return true;
}
```



## 18、反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例**

```
示例 1：
	输入：head = [1,2,3,4,5]
	输出：[5,4,3,2,1]
示例 2：
	输入：head = [1,2]
	输出：[2,1]
示例 3：
	输入：head = []
	输出：[]
```

**代码**

```c
struct ListNode* reverseList(struct ListNode* head){
    //使用辅助数组
    struct ListNode* p;
    p = head;
    int len = 0;
    while(p){
        len++;
        p = p->next;
    }

    int i = 0;
    //赋值到数组
    p = head;
    int * nums = malloc(sizeof(int)*len);
    while(p){
        nums[i] = p->val;
        p = p->next;
        i++; 
    }

    //翻转赋值到链表
    i = 0;
    p = head;
    while(p){
        p->val = nums[len-i-1];
        i++;
        p = p->next;
    }
    return head;
}
```



## 19、存在重复元素

给定一个整数数组，判断是否存在重复元素。

如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

**示例**

```
示例 1:
	输入: [1,2,3,1]
	输出: true
示例 2:
	输入: [1,2,3,4]
	输出: false
示例 3:
	输入: [1,1,1,3,3,4,3,2,4,2]
	输出: true
```

**代码**

```c
int cmp(const void* _a, const void* _b) {
    int a = *(int*)_a, b = *(int*)_b;
    return a - b;
}

bool containsDuplicate(int* nums, int numsSize) {
    qsort(nums, numsSize, sizeof(int), cmp);
    for (int i = 0; i < numsSize - 1; i++) {
        if (nums[i] == nums[i + 1]) {
            return true;
        }
    }
    return false;
}
```

算法正确, 复杂度 O(n^2) 不符合, 考虑使用排序来做

```c
bool containsDuplicate(int* nums, int numsSize){
    //暴力法
    int i,j;
    for(i = 0;i < numsSize;i++){
        for(j = 0;j < numsSize;j++){
            if(i == j)
                continue;
            if(nums[i] == nums[j])
                return true;
        }
    }
    return false;
}
```



## 20、汇总区间

给定一个无重复元素的有序整数数组 nums 。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

"a->b" ，如果 a != b
"a" ，如果 a == b

**示例**

```
示例 1：
    输入：nums = [0,1,2,4,5,7]
    输出：["0->2","4->5","7"]
    解释：区间范围是：
    [0,2] --> "0->2"
    [4,5] --> "4->5"
    [7,7] --> "7"
示例 2：
    输入：nums = [0,2,3,4,6,8,9]
    输出：["0","2->4","6","8->9"]
    解释：区间范围是：
    [0,0] --> "0"
    [2,4] --> "2->4"
    [6,6] --> "6"
    [8,9] --> "8->9"
示例 3：
    输入：nums = []
    输出：[]
示例 4：
    输入：nums = [-1]
    输出：["-1"]
示例 5：
    输入：nums = [0]
    输出：["0"]
```

**代码**

根据题意得出区间划分只有两种情况, 一种是存在连续的数字区间如: 1,2,3,4  = 1 → 4 , 一种是单独的数字 6 = 6,9 = 9,11=11。也即只需要对两种情况进行划分即可, 当存在连续数字, 取 *left* 开始 和 *end* 结束; 存在单独数字, 直接放到结果集中即可。

```c
char** summaryRanges(int* nums, int numsSize, int* returnSize) {
    char** ret = malloc(sizeof(char*) * numsSize);
    *returnSize = 0;
    int i = 0;
    while (i < numsSize) {
        int low = i;
        i++;
        while (i < numsSize && nums[i] == nums[i - 1] + 1) {
            i++;
        }
        int high = i - 1;
        char* temp = malloc(sizeof(char) * 25);
        sprintf(temp, "%d", nums[low]);
        if (low < high) {
            sprintf(temp + strlen(temp), "->");
            sprintf(temp + strlen(temp), "%d", nums[high]);
        }
        ret[(*returnSize)++] = temp;
    }
    return ret;
}
```



## 21、分数排名

编写一个 SQL 查询来实现分数排名。

如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。

**示例**

```
+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：

+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
```

**代码**

```sql
SELECT Score,
dense_rank() OVER(ORDER BY Score DESC) AS 'Rank'
FROM Scores;
```

**DENSE_RANK()**

`DENSE_RANK()`是一个[窗口函数](https://www.begtut.com/mysql/mysql-window-functions.html)，它为分区或结果集中的每一行分配排名，而排名值没有间隙。

行的等级从行前的不同等级值的数量增加1。

`DENSE_RANK()` 函数的语法如下：

```
DENSE_RANK() OVER (
    PARTITION BY <expression>[{,<expression>...}]
    ORDER BY <expression> [ASC|DESC], [{,<expression>...}]
) 
```

在这个语法中：

- 首先，`PARTITION BY`子句将`FROM`子句生成的结果集划分为分区。`DENSE_RANK()`函数应用于每个分区。
- 其次，`ORDER BY` 子句指定`DENSE_RANK()`函数操作的每个分区中的行顺序。

如果分区具有两个或更多具有相同排名值的行，则将为这些行中的每一行分配相同的排名。

**OVER**

over不能单独使用，要和分析函数：*rank*() , *dense_rank*() , *row_number*()等一起使用



## 22、丢失的数字(LC 268)

 给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。 

**示例**

```
示例 1：

输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
示例 2：

输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**代码**

```c
int missingNumber(int* nums, int numsSize){
    //范围在0 - numsSize
    //借用辅助空间
    int i = 0,result = 0;
    int * temp = malloc(sizeof(int) * (numsSize+1));
    //初始化 tag = 0
    for(i = 0;i <= numsSize;i++)
        temp[i] = 0;
    //记录信息 0 - numsSize
    for(i = 0;i < numsSize;i++){
        if(0 <= nums[i] && nums[i] <= numsSize){
            temp[nums[i]] = 1;    //修改标志为1,代表已经出现
        }
    }
    //遍历获取没有出现的那个数
    for(i = 0;i <= numsSize;i++){
        if(temp[i] == 0){
            result = i;
        }
    }
    return result;
}
```



## 23、Nim 游戏(LC 292)

你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。

- 你们轮流进行自己的回合，你作为先手。
- 每一回合，轮到的人拿掉 1 - 3 块石头。
- 拿掉最后一块石头的人就是获胜者。

 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。 

**示例**

```
示例 1：
	输入：n = 4
	输出：false 
	解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
示例 2：
	输入：n = 1
	输出：true
示例 3：
	输入：n = 2
	输出：true
```

**代码**

```
bool canWinNim(int n){
    return n % 4 == 0 ? false : true;
}
```



## 24、连续出现的数字(LC 180)

**示例**

```
表：Logs
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| num         | varchar |
+-------------+---------+
id 是这个表的主键。
编写一个 SQL 查询，查找所有至少连续出现三次的数字。
返回的结果表中的数据可以按 任意顺序 排列。

查询结果格式如下面的例子所示：
Logs 表：
+----+-----+
| Id | Num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+

Result 表：
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
1 是唯一连续出现至少三次的数字。
```

**代码**

```c
# Write your MySQL query statement below
SELECT DISTINCT
    log1.num as 'ConsecutiveNums'
FROM
    Logs log1,
    Logs log2,
    Logs log3
WHERE
    log1.id = log2.id -1 AND log2.id = log3.id - 1 AND
    log1.num = log2.num AND log2.num = log3.num;
```



## 25、两数相加(LC 2)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例**

示例1: 

![image-20211026210738762](img/image-20211026210738762.png)

```
	输入：l1 = [2,4,3], l2 = [5,6,4]
	输出：[7,0,8]
	解释：342 + 465 = 807.
示例 2：
	输入：l1 = [0], l2 = [0]
	输出：[0]
示例 3：
	输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
	输出：[8,9,9,9,0,0,0,1]
```

**代码**

```c
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    //使用进位的思想来计算
    //获取两个链表的长度, 用来动态生成数组
    struct ListNode * p,*q,*t;
    t = malloc(sizeof(struct ListNode));
    p = l1;
    q = l2;
    int lenA = 0;
    int lenB = 0;
    while(p){
        lenA++;
        p = p->next;
    }
    while(q){
        lenB++;
        q = q->next;
    }
    //扩宽比较短的链表长度, 与长的链表长度一致 - 可以采用
    int tag = 0;    //进位标志
    int plus = 0;   //各位相加和
    int i = 0;      //当前是第几位
    int * nums = malloc(sizeof(int)* (lenA > lenB ? lenA + 1 : lenB + 1));        //获取最大的长度加1 相加最大进一位
    while(l1 || l2){
        if(!l1){
            plus = 0 + l2->val; 
        } else if(!l2){
            plus = l1->val + 0; 
        } else if(l1 && l2){
            plus = l1->val + l2->val;
        }
        
        //不考虑进位先赋值
        nums[i] = (plus+tag) % 10;    //个位 % 10 仍然为原数

        //当前位是否有向上一级的进位
        if(plus+tag >= 10)
            tag = 1;
        else
            tag = 0;
        
        i++;
        if(l1)
            l1 = l1->next;
        if(l2)
            l2 = l2->next;
    }

    int j = 0;
    q = t;
    for(j = 0;j < i;j++){
        struct ListNode * h = malloc(sizeof(struct ListNode));
        h->val = nums[j];
        t->next = h;
        t = t->next;
    }
    //9 + 9 = 18 8 1 没有 1 位, 这里加上
    if(tag == 1){
        struct ListNode * h = malloc(sizeof(struct ListNode));
        h->val = 1;
        t->next = h;
        t = t->next;
    }
    t->next = NULL;
    return q->next;
}
```

转为整型计算再分割存入链表 - 精度比较小, 限制在 int / long 范围内

```c
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode * p,*q,*t;
    p = l1;
    q = l2;
    t = malloc(sizeof(struct ListNode));
    int reverseA = 0;
    int reverseB = 0;
    //转为int计算再转为链表
    int i = 0;
    while(l1){
        reverseA += l1->val * pow(10,i);
        l1 = l1->next;
        i++;
    }
    i = 0;
    while(l2){
        reverseB += l2->val * pow(10,i);
        l2 = l2->next;
        i++;
    }
    int final = reverseA + reverseB;
    p = t;
    //将结果存到链表
    //处理边界条件 两个链表都为0的情况
    if(final == 0){
        struct ListNode * h = malloc(sizeof(struct ListNode));
        h->val = 0;    //各位开始存,结果是反的
        t->next = h;
        t = t->next;
    } else{
        while(final){
            struct ListNode * h = malloc(sizeof(struct ListNode));
            h->val = final % 10;    //各位开始存,结果是反的
            t->next = h;
            t = t->next;
            final/=10;
        }
    }
    t->next = NULL;
    return p->next;
}
```



## 26、2的幂

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得$n = 2^x$ ，则认为 n 是 2 的幂次方。

**示例**

```c
示例 1：
	输入：n = 1
	输出：true
	解释：20 = 1
示例 2：
	输入：n = 16
	输出：true
	解释：24 = 16
示例 3：
	输入：n = 3
	输出：false
示例 4：
	输入：n = 4
	输出：true
示例 5：
	输入：n = 5
	输出：false
```

**代码**

**进制转换思想** 利用2的幂转换为2进制一定只含有一个1来判断是否是2的幂次 1 = 1  10 = 2  100 = 4 1000 = 8 

```c
bool isPowerOfTwo(int n){
    int tag = 0;
    while(n){
        tag += n % 2;
        n /= 2;
    }
    return tag == 1 ? true : false;
}
```

**暴力法**    这里可以通过一些方法来缩减复杂度, 先获取 n 的 i * i = n 的情况, 抛去 n % 2 != 0的情况等

```c
bool isPowerOfTwo(int n){
    int i;
    for(i = 0;i < n;i++){
        if(pow(2,i) == n)
            return true;
    }
    return false;
}
```



## 27、3的幂(LC 326)

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == $3^x$

**示例**

```
示例 1：
	输入：n = 27
	输出：true
示例 2：
	输入：n = 0
	输出：false
示例 3：
	输入：n = 9
	输出：true
示例 4：
	输入：n = 45
	输出：false
```

**代码**

**进制转换思想** 利用3的幂转换为3进制一定只含有一个1来判断是否是3的幂次  1 = 1  10 = 3  100 = 9 1000 = 27 

```c
bool isPowerOfThree(int n){
    int tag = 0;
    while(n){
        tag += n % 3;
        n /= 3;
    }
    return tag == 1 ? true : false;
}
```



## 28、4的幂(LC 342)

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == $4^x$

 **示例**

```
示例 1：
	输入：n = 16
	输出：true
示例 2：
	输入：n = 5
	输出：false
示例 3：
	输入：n = 1
	输出：true
```

**代码**

**进制转换思想** 利用4的幂转换为4进制一定只含有一个1来判断是否是4的幂次  1 = 1  10 = 4  100 = 16 1000 = 64 

```c
bool isPowerOfFour(int n){
    int tag = 0;
    while(n){
        tag += n % 4;
        n /= 4;
    }
    return tag == 1 ? true : false;
}
```



## 29、各位相加(LC 258)

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。

**示例**

```
输入: 38
输出: 2 
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
```

**代码**

**循环分割相加直到结果<10**。 首先统计位数生成间接数组, 循环 存放分割结果循环相加直到结果 < 10。

```c
int addDigits(int num){
    //统计数字位数
    int len = 0;
    int temp = num;
    while(temp){
        len++;
        temp /= 10;
    }

    //生成间接数组
    int * nums = malloc(sizeof(int)*len);
    int result = 10;     //结果,循环终止条件
    while(result >= 10){
        //分割数组
        int i = 0;
        result = 0;
        while(num){
            nums[i] = num % 10;
            num /= 10; 
            result += nums[i];
            i++;
        }
        num = result;
    }
    return result;
}
```



## 30、汉明距离(LC 461)

两个整数之间的汉明距离数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

**示例**

```
示例 1：
	输入：x = 1, y = 4
	输出：2
	解释：
	1   (0 0 0 1)
	4   (0 1 0 0)
  	     ↑   ↑
	上面的箭头指出了对应二进制位不同的位置。
示例 2：
	输入：x = 3, y = 1
	输出：1

```

**代码**

内置函数

```c
int hammingDistance(int x, int y) {
    return __builtin_popcount(x ^ y);
}
```

转换为二进制各位存放到数组, 挨个比较

```c
int hammingDistance(int x, int y){
    //计算长度
    int lenA = 0;
    int lenB = 0;
    int temp = x;
    while(temp){
        lenA++;
        temp /= 2;
    }
    temp = y;
    while(temp){
        lenB++;
        temp /= 2;
    }

    int * numsA = malloc(sizeof(int)*lenA);
    int * numsB = malloc(sizeof(int)*lenB);
    //二进制存储到数组中



}
```



## 31、删除链表中的节点(自删 LC 237)

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

![img](img/237_example.png)

```c
示例 1：
	输入：head = [4,5,1,9], node = 5
	输出：[4,1,9]
	解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2：
	输入：head = [4,5,1,9], node = 1
	输出：[4,5,9]
	解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

**代码**

模仿数组删除 覆盖移除尾结点

```c
void deleteNode(struct ListNode* node) {
    struct ListNode * p,* q;
    p = node;
    q = node->next;
    while(q){
        p->val = q->val;
        //赋值完毕,直接退出,不再移动结点
        if(q->next == NULL)
            break;
        p = p->next;
        q = q->next;
    }
    p->next = NULL;
}
```



## 32、比特数计数(LC 338)

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例**

```
示例 1：
	输入：n = 2
	输出：[0,1,1]
	解释：
	0 --> 0
	1 --> 1
	2 --> 10
示例 2：
	输入：n = 5
	输出：[0,1,1,2,1,2]
    解释：
    0 --> 0
    1 --> 1
    2 --> 10
    3 --> 11
    4 --> 100
    5 --> 101
```

**代码**

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int * countBits(int n, int* returnSize){
    //间接数组
    int * result = malloc(sizeof(int)*(n+1));     //存放结果
    //转换为2进制
    int i = 0;
    int tag = 0;    //计数 1 的个数
    int num = 0;    //存放转换后的结果数组
    for(i = 0;i <= n;i++){
        num = i;
        //转换为2进制
        while(num){
            int flag = num % 2;       //2进制各位
            num /= 2;
            if(flag == 1)
                tag++;
        }
        result[i] = tag;
        tag = 0;    //重置用于下次计数
    }
    *returnSize = n+1;
    return result;
}
```



## 33、两个数组的交集(LC 349)

给定两个数组，编写一个函数来计算它们的交集。

**示例**

 ```
示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 ```

**代码**

暴力遍历 + 去重

```c
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    //暴力法
    int len = nums1Size > nums2Size ? nums2Size : nums1Size;    //返回较小的,最大结果
    int * nums = malloc(sizeof(int)*len);
    //暴力遍历
    int i,j,k,tag = 0;
    for(i = 0;i < nums1Size;i++){
        for(j = 0;j < nums2Size;j++){
            //去重
            for(k = 0;k < tag;k++)
                if(nums1[i] == nums[k])
                    break;
            if(nums1[i] == nums2[j] && k == tag)
                nums[tag++] = nums1[i];
        }
    }
    * returnSize = tag;
    return nums;
}
```



## 34、两个数组的交集(LC 350)

给定两个数组，编写一个函数来计算它们的交集。

**示例**

```c
示例 1：
	输入：nums1 = [1,2,2,1], nums2 = [2,2]
	输出：[2,2]
示例 2:
	输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
	输出：[4,9]
```

**代码**

冒泡排序 + 双指针 先排序然后使用双指针遍历两个数组, 获取结果。

```c
int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    //使用排序的思想进行排序
    int i,j;
    for(i = 0;i < nums1Size-1;i++){
        for(j = 0;j < nums1Size - i - 1;j++){
            if(nums1[j] > nums1[j+1]){
                int temp = nums1[j];
                nums1[j] = nums1[j+1];
                nums1[j+1] = temp;
            }
        }
    }
    for(i = 0;i < nums2Size-1;i++){
        for(j = 0;j < nums2Size - i - 1;j++){
            if(nums2[j] > nums2[j+1]){
                int temp = nums2[j];
                nums2[j] = nums2[j+1];
                nums2[j+1] = temp;
            }
        }
    }
    //指针比较 由于是升序排列, 小的数组应该前移, 直到连个数组中某个数组比较完毕
    int a = 0,b = 0,size = 0;
    int len = nums1Size > nums2Size ? nums2Size : nums1Size;    //返回小的
    int * nums = malloc(sizeof(int)*len);
    while(a < nums1Size && b < nums2Size){
        if(nums1[a] == nums2[b]){
            nums[size++] = nums1[a];
            a++;
            b++;
        } else if(nums1[a] < nums2[b]){
            a++;
        } else{
            b++;
        }
        len--;
    }
    *returnSize = size;
    return nums;
}
```



## 35、有效的完全平方数

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

**示例**

```c
示例 1：
    输入：num = 16
    输出：true
示例 2：
    输入：num = 14
    输出：false
```

**代码**

使用内置的开方函数 sqrt()

```c
bool isPerfectSquare(int num){
    int a = sqrt(num);
    return pow(a,2) == num; 
}
```



## 36、猜数字大小

猜数字游戏的规则如下：

每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：

-1：我选出的数字比你猜的数字小 pick < num
1：我选出的数字比你猜的数字大 pick > num
0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
返回我选出的数字。

**示例**

 ```
示例 1：
    输入：n = 10, pick = 6
    输出：6
示例 2：
    输入：n = 1, pick = 1
    输出：1
示例 3：
    输入：n = 2, pick = 1
    输出：1
示例 4：
    输入：n = 2, pick = 2
    输出：2
 ```

**代码**

超时 在数字比较大的情况, 运算时间过长

```
int guessNumber(int n){
	//遍历挨个猜, 不使用step计数
    int i,result;
    for(i = 0;i <= n;i++){
        if(!guess(i)){
            result = i;
            break;
        }  
    }
    return result;
}
```

二分法查找

```c
int guessNumber(int n){
    //二分查找的办思想
    int left = 0,right = n,result;
    while(left <= right){
        int mid = left + (right - left) / 2;
        if(!guess(mid)){
            result = mid;
            break;
        }
        else if(guess(mid) < 0)
            right = mid - 1;
        else if(guess(mid) > 0)
            left = mid + 1;
    }
    return result;
}
```



## 37、赎金信(LC 383)

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

**示例**

 ```
示例 1：
	输入：ransomNote = "a", magazine = "b"
	输出：false
示例 2：
	输入：ransomNote = "aa", magazine = "ab"
	输出：false
示例 3：
	输入：ransomNote = "aa", magazine = "aab"
	输出：true
 ```

**代码**

间接数组记录字符出现次数, magazine中有足够构成ransomNote的字符个数即可

```c
bool canConstruct(char * ransomNote, char * magazine){
    //magazine中有足够构成ransomNote的字符个数即可
    //只含有小写字母 26 个使用 ASCII 判断
    int * nums1 = malloc(sizeof(int) * 26);
    int * nums2 = malloc(sizeof(int) * 26);
    //初始化每个位置为0
    memset(nums1,0,26);
    memset(nums2,0,26);
    while(*ransomNote){
        nums1[(int)*ransomNote - 97]++;   //存放到对应位置
        ransomNote++;
    }
    while(*magazine){
        nums2[(int)*magazine - 97]++;   //存放到对应位置
        magazine++;
    }
    int i;
    for(i = 0;i < 26;i++){
        if(nums1[i] == 0)
            continue;
        if(nums1[i] > nums2[i])
            break;
    }
    return i == 26 ? true : false;
}
```



## 38、字符串中的第一个唯一字符

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**示例**

```
s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
```

**代码**

数组存放字符出现次数, 再从头遍历字符串找到第一个出现次数为1的下标位置。

```c
int firstUniqChar(char * s){
    //使用之前使用过的 间接数组记录出现次数,然后对比
    int nums[26] = {0};
    char * temp;
    temp = s;
    int index = -1;      //结果 记录下标
    //遍历记录出现次数
    while(*temp){
        nums[(int)*temp - 97]++;
        temp++;
    }
    //从s头部开始依次遍历得到第一个 nums[i] = 1 的字符下标
    temp = s;
    int tag = 0;
    while(*temp){
        if(nums[(int)*temp - 97] == 1){
            index = tag;
            break;
        }     
        temp++;
        tag++;
    }
    return index;
}
```

思路一样, 使用数组操作的方式进行遍历

```c
int firstUniqChar(char * s){
    int a[26] = {0};
    int len = strlen(s);
    int i;

    for (i = 0; i < len; i++)
        a[s[i] - 'a']++;

    for (i = 0; i < len; i++) {
        if (a[s[i] - 'a'] == 1)
            return i;
    }

    return -1;
}
```

暴力法 超出时间限制。 使用

```c
int firstUniqChar(char * s){
    //暴力法
    char * m,* n;
    m = n = s;
    int tag = 0;		 //记录比较到的下标位置
    int index = -1;      //保存获取的下标
    while(*n){
        m = s;
        int flag = 0;       //判断是否出现了重复 0 代表不重复
        while(*m){
            //跳过n指向的位置
            if(m == n){
                m++;
                continue;
            }
            //记录 n 对应的字符出现了机次
            if(*n == *m)
                flag++;
            m++;
        }
        //flag = 0 代表一次都没有出现
        if(flag == 0){
            index = tag;
            break;
        }
        n++;
        tag++;
    }
    return index;
}
```



## 39、找不同(LC 389)

给定两个字符串 s 和 t，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母。

 **示例**

```
示例 1：
    输入：s = "abcd", t = "abcde"
    输出："e"
    解释：'e' 是那个被添加的字母。
示例 2：
    输入：s = "", t = "y"
    输出："y"
示例 3：
    输入：s = "a", t = "aa"
    输出："a"
示例 4：
    输入：s = "ae", t = "aea"
    输出："a"
```

**代码**

间接数组计数 得出str1中出现次数小于str2中出现次数的字符即为所求

```c
char findTheDifference(char * s, char * t){
    int nums1[26] = {0};
    int nums2[26] = {0};
    int i,lenA = strlen(s);
    //计算出现次数到数组中
    for(i = 0;i < lenA;i++)
        nums1[s[i] - 'a']++;
    for(i = 0;i < lenA+1;i++)
        nums2[t[i] - 'a']++;
    //遍历数组 对比nums1中次数=0,但nums2次数=1的即为所求
    for(i = 0;i <26;i++){
        if(nums1[i] < nums2[i])
            break;
    }
    return (char)i+97;
}
```



## 40、翻转字符串中的元音字母

给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。

字符串内可能包含所有 ASCII 码字符, 大小写

**示例**

 ```
 示例 1：
 	输入：s = "hello"
 	输出："holle"
 示例 2：
 	输入：s = "leetcode"
 	输出："leotcede"
 ```

**代码**

暴力遍历 - 这个代码长度很高, 可以使用数组来存放对应结构。

```c
char * reverseVowels(char * s){
    //使用间接数组存放结果
    int len = strlen(s);
    int * nums = malloc(sizeof(int)*len);
    int * reverse = malloc(sizeof(int)*len);
    int i = 0;
    //记录结果
    int tag = 0;
    for(i = 0;i < len;i++){
        switch(s[i]){
            case 'a':
                nums[i] = 1;
                break;
            case 'e':
                nums[i] = 2;
                break;
            case 'i':
                nums[i] = 3;
                break;
            case 'o':
                nums[i] = 4;
                break;
            case 'u':
                nums[i] = 5;
                break;
            case 'A':
                nums[i] = 6;
                break;
            case 'E':
                nums[i] = 7;
                break;
            case 'I':
                nums[i] = 8;
                break;
            case 'O':
                nums[i] = 9;
                break;
            case 'U':
                nums[i] = 10;
                break;
            default:
                nums[i] = 0;
                break;
        }
        if(nums[i] != 0)
            reverse[tag++] = nums[i];
    }
    //整个转置
    for(i = 0;i < tag/2;i++){
        int temp = reverse[i];
        reverse[i] = reverse[tag-i-1];
        reverse[tag-i-1] = temp;
    }
    //根据reverse数组内翻转后的情况进行赋值
    tag = 0;
    for(i = 0;i < len;i++){
        if(nums[i] != 0){
            switch(reverse[tag++]){
                case 1:
                    s[i] = 'a';
                    break;
                case 2:
                    s[i] = 'e';
                    break;
                case 3:
                    s[i] = 'i';
                    break;
                case 4:
                    s[i] = 'o';
                    break;
                case 5:
                    s[i] = 'u';
                    break;
                case 6:
                    s[i] = 'A';
                    break;
                case 7:
                    s[i] = 'E';
                    break;
                case 8:
                    s[i] = 'I';
                    break;
                case 9:
                    s[i] = 'O';
                    break;
                case 10:
                    s[i] = 'U';
                    break;
            }
        }
    }
    return s;
}
```

使用间接数组 - 修改后

```c
char * reverseVowels(char * s){
    //使用间接数组存放结果
    int len = strlen(s);
    int * nums = malloc(sizeof(int)*len);
    int * reverse = malloc(sizeof(int)*len);
    int str[10] = {'a','e','i','o','u','A','E','I','O','U'};
    int i = 0,j = 0;
    //记录结果
    int tag = 0;
    for(i = 0;i < len;i++){
        for(j = 0;j < 10;j++)
            if(s[i] == str[j]){
                nums[i] = j+1;
                break;
            } 
        if(j == 10)
            nums[i] = 0;
        if(nums[i] != 0)
            reverse[tag++] = nums[i];
    }

    //整个转置
    for(i = 0;i < tag/2;i++){
        int temp = reverse[i];
        reverse[i] = reverse[tag-i-1];
        reverse[tag-i-1] = temp;
    }


    //根据reverse数组内翻转后的情况进行赋值
    tag = 0;
    for(i = 0;i < len;i++){
        if(nums[i] != 0){
           for(j = 0;j < 10;j++){
                if(reverse[tag] == j+1){
                    s[i] = str[j];
                    tag++;
                    break;
                }   
           }
        }
    }
    return s;
}
```



## 41、数字转为十六进制数(LC 405)  查看移位 & | >> <<操作符学习

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 **补码运算** 方法。

> 注意:
>
> 十六进制中所有字母(a-f)都必须是小写。
> 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
> 给定的数确保在32位有符号整数范围内。
> 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

**示例**

```
示例 1：
    输入:
    26
    输出:
    "1a"
示例 2：
    输入:
    -1
    输出:
    "ffffffff"
```

**代码**

```c
char * toHex(int num){
    //16进制对应的字符
    char str[16]={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
    char * reverse; //结果数组
    //分配空间 - 足底啊32位整型,16进制则为9位
    reverse = (char *)malloc(sizeof(char) * 9);    
    int i = 0;
    //倒序存放
    for(i = 7 ;i >= 0;i--){
        reverse[i] = str[num & 0xF];      //每位16进制
        num = num>>4;
    }
    //在最后加上终止字符, 防止识别不到终止, 长度越界
    reverse[8]='\0';
    //不满8位时存在前缀0, 去除前缀0
    while(reverse[0]=='0' && *(reverse+1)!='\0')    reverse++;
    return reverse;
}
```



## 42、最长回文串(LC 409)

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

**示例**

```
示例 1:
	输入:
	"abccccdd"
	输出:
	7
	解释:
	我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

**代码**

```c
int longestPalindrome(char * s){
    //间接数组存放出现次数
    int nums[52] = {0};  //区分大小写
    //统计出现次数
    char * temp = s;
    int tag = 0;
    while(*temp){
        if(*temp >= 'A' && *temp <= 'Z'){
            nums[*temp++ - 'A']++;      //0 - 26 27 - 52个
        } else if(*temp >= 'a' && *temp <= 'z'){
            nums[*temp++ - 'a' + 26]++;      //0 - 26 27 - 52个
        }
    }
        
    //拿到了次数,进行构造
    //奇数次放中间, 偶数次放两边
    int i = 0;
    int resLen = 0;
    int max = 0;
    int index = 0;
    for(i = 0;i < 52;i++){
        //奇数时, 出现次数为奇数中最大的
        if(nums[i] % 2 != 0){
            if(max < nums[i]){
                max = nums[i];
                index = i;
            }
            resLen += nums[i] -1;       //去掉1位就可以构造
        }
        if(nums[i] % 2 == 0){
            resLen += nums[i];
        }
    }
    if(max != 0)
        resLen -= nums[index] - 1;
    return resLen + max;
}
```



## 43、Fizz Buzz(LC 412)

给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：

answer[i] == "FizzBuzz" 如果 i 同时是 3 和 5 的倍数。
answer[i] == "Fizz" 如果 i 是 3 的倍数。
answer[i] == "Buzz" 如果 i 是 5 的倍数。
answer[i] == i 如果上述条件全不满足。

**示例**

```
示例 1：
	输入：n = 3
	输出：["1","2","Fizz"]
示例 2：
	输入：n = 5
	输出：["1","2","Fizz","4","Buzz"]
示例 3：
	输入：n = 15
	输出：			["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
```

**代码**

```c
//如果直接用 strcpy会出现 *** buffer overflow detected ***: terminated错误
char *g1 = "FizzBuzz";
char *g2 = "Fizz";
char *g3 = "Buzz";

char ** fizzBuzz(int n, int* returnSize){
    char ** str = (char **)malloc(sizeof(char *) * n);
    int i;
    for(i = 1;i <= n;i++){
        str[i - 1] = (char *)malloc(sizeof(char) * 8);
        if(i % 3 == 0 && i % 5 == 0){
            str[i-1] = g1;
        } else if(i % 3 == 0){
            str[i-1] = g2;
        } else if(i % 5 == 0){
            str[i-1] = g3;
        } else{
            sprintf(str[i-1],"%d",i);
        }
    }
    *returnSize = n;
    return str;
}
```



## 44、第三大的数(LC 414)

给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。

 **示例**

```
示例 1：
    输入：[3, 2, 1]
    输出：1
    解释：第三大的数是 1 。
示例 2：
    输入：[1, 2]
    输出：2
    解释：第三大的数不存在, 所以返回最大的数 2 。
示例 3：
    输入：[2, 2, 3, 1]
    输出：1
    解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
    此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
```

**代码**

```c
int thirdMax(int* nums, int numsSize){
    int result[3] = {0};
    int i,j;
    //冒泡排序排3次 降序
    for(i = 0;i < numsSize-1;i++){
        for(j = 0;j <numsSize-i-1;j++){
            if(nums[j] < nums[j+1]){
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
    //赋值到结果数组
    int flag = 0;
    int tag = 0;
    for(j = 0;j < numsSize;j++){
        if(tag == 3)    break;
        result[tag] = nums[j];
        while(result[tag] == nums[j+1 >= numsSize ? j : j+1]){
            if(j+1 == numsSize)
                break;
            j++;
        }
        printf("%d ",result[tag]);
        tag++;
    }
        
    return tag == 3 ? result[2] : result[0];
}
```



## 45、字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

**示例**

 ```
 示例 1：
 	输入：num1 = "11", num2 = "123"
 	输出："134"
 示例 2：
 	输入：num1 = "456", num2 = "77"
 	输出："533"
 示例 3：
 	输入：num1 = "0", num2 = "0"
 	输出："0"
 ```

**代码**

暴力法  字符串->数组->相加(考虑进位的实现)->字符串->考虑边界条件(2个两位数字相加构成3位的情况)->返回结果

```c
char * addStrings(char * num1, char * num2){
    int i = 0;
    int len1 = strlen(num1);
    int len2 = strlen(num2);
    int maxLen = len1 > len2 ? len1 : len2;
    //生成间接数组,存放各位
    int * nums1 = malloc(sizeof(int) * maxLen);
    int * nums2 = malloc(sizeof(int) * maxLen);
    for(i = 0;i < maxLen;i++){
        nums1[i] = nums2[i] = 0;
    }
    //取各位
    int tag = maxLen - 1;   //从末尾开始赋值,长度不够前面都为0
    for(i = len1 - 1;i >= 0;i--){
        nums1[tag--] = num1[i] - '0';
    }
    tag = maxLen - 1;
    for(i = len2-1;i >= 0;i--){
        nums2[tag--] = num2[i]  - '0';;
    }

    //赋值完毕开始相加
    int * result = malloc(sizeof(int)*(maxLen+1));  //生成结果数组
    for(i = 0;i < maxLen;i++){
        result[i]  = 0;
    }
    tag = 0;        //进位符号
    for(i = maxLen - 1;i >= 0;i--){
        if(tag == 1){
            result[i] += tag;   //进位
            tag = 0;
        }  
        result[i] += nums1[i] + nums2[i];
        if(result[i] >= 10){
            tag = 1;
            result[i] %= 10;
        } 
    }

    //转换为字符串
    char * str = malloc(sizeof(char) * (maxLen+1));
    for(i = 0;i < maxLen;i++){
        str[i] = result[i] + '0';
    }
    str[maxLen] = '\0';
    //没有进位. 这里需要处理进位的情况 19 + 91 = 110 结果为 10  -> 
    char * final = malloc(sizeof(char) * (maxLen+2));
    final[0] = '1';
    for(i = 0;i < maxLen;i++){
        final[i+1] = str[i];
    }
    final[maxLen+1] = '\0';
    return tag == 0 ? str : final;
}
```



## 46、字符串中的单词数

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**示例**

```
输入: "Hello, my name is John"
输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
```

**代码**

主要讲究理解题意 懂了就很简单

```c
int countSegments(char * s){
    int size = 0;
    char pre = ' ';
    //上一个是空格,下一个不是空格就是一个单词
    //' m' ' ,' 这里是从头部进行判断是否是一个单词
    while(*s){
        if(pre == ' ' && *s !=  ' ')
            size++;
        pre = *s;
        s++;
    }
    return size;
}
```





